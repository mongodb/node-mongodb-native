import { expect } from 'chai';

import {
  PoolClosedError as MongoPoolClosedError,
  WaitQueueTimeoutError as MongoWaitQueueTimeoutError
} from '../../src/cmap/errors';
import {
  isRetryableEndTransactionError,
  isSDAMUnrecoverableError,
  LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE,
  LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE,
  MongoSystemError,
  NODE_IS_RECOVERING_ERROR_MESSAGE
} from '../../src/error';
import * as importsFromErrorSrc from '../../src/error';
import {
  MongoError,
  MongoNetworkError,
  MongoParseError,
  MongoServerError,
  MongoWriteConcernError,
  TopologyDescription
} from '../../src/index';
import * as importsFromEntryPoint from '../../src/index';
import { Topology, TopologyOptions } from '../../src/sdam/topology';
import { isHello, ns, setDifference } from '../../src/utils';
import { ReplSetFixture } from '../tools/common';
import { cleanup } from '../tools/mongodb-mock/index';
import { getSymbolFrom } from '../tools/utils';

describe('MongoErrors', () => {
  let errorClassesFromEntryPoint = Object.fromEntries(
    Object.entries(importsFromEntryPoint).filter(
      ([key, value]) => key.endsWith('Error') && value.toString().startsWith('class')
    )
  ) as any;
  errorClassesFromEntryPoint = {
    ...errorClassesFromEntryPoint,
    MongoPoolClosedError,
    MongoWaitQueueTimeoutError
  };

  const errorClassesFromErrorSrc = Object.fromEntries(
    Object.entries(importsFromErrorSrc).filter(
      ([key, value]) => key.endsWith('Error') && value.toString().startsWith('class')
    )
  );

  it('all defined errors should be public', () => {
    expect(
      setDifference(Object.keys(errorClassesFromEntryPoint), Object.keys(errorClassesFromErrorSrc))
    ).to.have.property('size', 3);

    expect(
      setDifference(Object.keys(errorClassesFromErrorSrc), Object.keys(errorClassesFromEntryPoint))
    ).to.have.property('size', 0);
  });

  describe('error names should be read-only', () => {
    for (const [errorName, errorClass] of Object.entries(errorClassesFromEntryPoint)) {
      it(`${errorName} should be read-only`, () => {
        // Dynamically create error class with message
        const error = new (errorClass as any)('generated by test', {});
        // expect name property to be class name
        expect(error).to.have.property('name', errorName);

        try {
          error.name = 'renamed by test';
          // eslint-disable-next-line no-empty
        } catch (err) {}
        expect(error).to.have.property('name', errorName);
      });
    }
  });

  describe('MongoError#constructor', () => {
    it('should accept a string', function () {
      const errorMessage = 'A test error';
      const err = new MongoError(errorMessage);
      expect(err).to.be.an.instanceof(Error);
      expect(err.name).to.equal('MongoError');
      expect(err.message).to.equal(errorMessage);
    });

    it('should accept an Error object', () => {
      const errorMessage = 'A test error';
      const err = new MongoError(new Error(errorMessage));
      expect(err).to.be.an.instanceof(Error);
      expect(err.name).to.equal('MongoError');
      expect(err.message).to.equal(errorMessage);
    });
  });

  describe('MongoServerError#constructor', () => {
    it('should accept an object', function () {
      const errorMessage = 'A test error';
      const err = new MongoServerError({ message: errorMessage, someData: 12345 });
      expect(err).to.be.an.instanceof(Error);
      expect(err.name).to.equal('MongoServerError');
      expect(err.message).to.equal(errorMessage);
      expect(err.someData).to.equal(12345);
    });
  });

  describe('MongoNetworkError#constructor', () => {
    it('should accept a string', function () {
      const errorMessage = 'A test error';
      const err = new MongoNetworkError(errorMessage);
      expect(err).to.be.an.instanceof(Error);
      expect(err).to.be.an.instanceof(MongoError);
      expect(err.name).to.equal('MongoNetworkError');
      expect(err.message).to.equal(errorMessage);
    });
  });

  describe('MongoSystemError#constructor', () => {
    context('when the topology description contains an error code', () => {
      it('contains the specified code as a top level property', () => {
        const topologyDescription = {
          error: {
            code: 123
          }
        } as TopologyDescription;

        const error = new MongoSystemError('something went wrong', topologyDescription);
        expect(error).to.haveOwnProperty('code', 123);
      });
    });

    context('when the topology description does not contain an error code', () => {
      it('contains the code as a top level property that is undefined', () => {
        const topologyDescription = { error: {} } as TopologyDescription;

        const error = new MongoSystemError('something went wrong', topologyDescription);
        expect(error).to.haveOwnProperty('code', undefined);
      });
    });

    context('when the topology description does not contain an error property', () => {
      it('contains the code as a top level property that is undefined', () => {
        const topologyDescription = {} as TopologyDescription;

        const error = new MongoSystemError('something went wrong', topologyDescription);
        expect(error).to.haveOwnProperty('code', undefined);
      });
    });
  });

  describe('#isRetryableEndTransactionError', function () {
    context('when the error has a RetryableWriteError label', function () {
      const error = new MongoNetworkError('');
      error.addErrorLabel('RetryableWriteError');

      it('returns true', function () {
        expect(isRetryableEndTransactionError(error)).to.be.true;
      });
    });

    context('when the error does not have a RetryableWriteError label', function () {
      const error = new MongoNetworkError('');
      error.addErrorLabel('InvalidLabel');

      it('returns false', function () {
        expect(isRetryableEndTransactionError(error)).to.be.false;
      });
    });

    context('when the error does not have any label', function () {
      const error = new MongoNetworkError('');

      it('returns false', function () {
        expect(isRetryableEndTransactionError(error)).to.be.false;
      });
    });
  });

  describe('#isSDAMUnrecoverableError', function () {
    context('when the error is a MongoParseError', function () {
      it('returns true', function () {
        const error = new MongoParseError('');
        expect(isSDAMUnrecoverableError(error)).to.be.true;
      });
    });

    context('when the error is null', function () {
      it('returns true', function () {
        expect(isSDAMUnrecoverableError(null)).to.be.true;
      });
    });

    context('when the error has a "node is recovering" error code', function () {
      it('returns true', function () {
        const error = new MongoError('');
        // Code for NotPrimaryOrSecondary
        error.code = 13436;
        expect(isSDAMUnrecoverableError(error)).to.be.true;
      });
    });

    context('when the error has a "not writable primary" error code', function () {
      it('returns true', function () {
        const error = new MongoError('');
        // Code for NotWritablePrimary
        error.code = 10107;
        expect(isSDAMUnrecoverableError(error)).to.be.true;
      });
    });

    context(
      'when the code is not a "node is recovering" error and not a "not writable primary" error',
      function () {
        it('returns false', function () {
          // If the response includes an error code, it MUST be solely used to determine if error is a "node is recovering" or "not writable primary" error.
          const error = new MongoError(NODE_IS_RECOVERING_ERROR_MESSAGE);
          error.code = 555;
          expect(isSDAMUnrecoverableError(error)).to.be.false;
        });
      }
    );

    context(
      'when the error message contains the legacy "not primary" message and no error code is used',
      function () {
        it('returns true', function () {
          const error = new MongoError(`this is ${LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE}.`);
          expect(isSDAMUnrecoverableError(error)).to.be.true;
        });
      }
    );

    context(
      'when the error message contains "node is recovering" and no error code is used',
      function () {
        it('returns true', function () {
          const error = new MongoError(`the ${NODE_IS_RECOVERING_ERROR_MESSAGE} from an error`);
          expect(isSDAMUnrecoverableError(error)).to.be.true;
        });
      }
    );

    context(
      'when the error message contains the legacy "not primary or secondary" message and no error code is used',
      function () {
        it('returns true', function () {
          const error = new MongoError(
            `this is ${LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE}, so we have a problem `
          );
          expect(isSDAMUnrecoverableError(error)).to.be.true;
        });
      }
    );
  });

  describe('when MongoNetworkError is constructed', () => {
    it('should only define beforeHandshake symbol if boolean option passed in', function () {
      const errorWithOptionTrue = new MongoNetworkError('', { beforeHandshake: true });
      expect(getSymbolFrom(errorWithOptionTrue, 'beforeHandshake', false)).to.be.a('symbol');

      const errorWithOptionFalse = new MongoNetworkError('', { beforeHandshake: false });
      expect(getSymbolFrom(errorWithOptionFalse, 'beforeHandshake', false)).to.be.a('symbol');

      const errorWithBadOption = new MongoNetworkError('', {
        // @ts-expect-error: beforeHandshake must be a boolean value
        beforeHandshake: 'not boolean'
      });
      expect(getSymbolFrom(errorWithBadOption, 'beforeHandshake', false)).to.be.an('undefined');

      const errorWithoutOption = new MongoNetworkError('');
      expect(getSymbolFrom(errorWithoutOption, 'beforeHandshake', false)).to.be.an('undefined');
    });
  });

  describe('WriteConcernError', function () {
    let test;
    const RAW_USER_WRITE_CONCERN_CMD = {
      createUser: 'foo2',
      pwd: 'pwd',
      roles: ['read'],
      writeConcern: { w: 'majority', wtimeoutMS: 1 }
    };

    const RAW_USER_WRITE_CONCERN_ERROR = {
      ok: 0,
      errmsg: 'waiting for replication timed out',
      code: 64,
      codeName: 'WriteConcernFailed',
      writeConcernError: {
        code: 64,
        codeName: 'WriteConcernFailed',
        errmsg: 'waiting for replication timed out',
        errInfo: {
          wtimeout: true
        }
      }
    };

    const RAW_USER_WRITE_CONCERN_ERROR_INFO = {
      ok: 0,
      errmsg: 'waiting for replication timed out',
      code: 64,
      codeName: 'WriteConcernFailed',
      writeConcernError: {
        code: 64,
        codeName: 'WriteConcernFailed',
        errmsg: 'waiting for replication timed out',
        errInfo: {
          writeConcern: {
            w: 2,
            wtimeout: 0,
            provenance: 'clientSupplied'
          }
        }
      }
    };

    before(() => (test = new ReplSetFixture()));
    afterEach(() => cleanup());
    beforeEach(() => test.setup());

    function makeAndConnectReplSet(cb) {
      let invoked = false;
      const replSet = new Topology(
        [test.primaryServer.hostAddress(), test.firstSecondaryServer.hostAddress()],
        { replicaSet: 'rs' } as TopologyOptions
      );

      replSet.once('error', err => {
        if (invoked) {
          return;
        }
        invoked = true;
        cb(err);
      });

      replSet.on('connect', () => {
        if (invoked) {
          return;
        }

        invoked = true;
        cb(undefined, replSet);
      });

      replSet.connect();
    }

    it('should expose a user command writeConcern error like a normal WriteConcernError', function (done) {
      test.primaryServer.setMessageHandler(request => {
        const doc = request.document;
        if (isHello(doc)) {
          setTimeout(() => request.reply(test.primaryStates[0]));
        } else if (doc.createUser) {
          setTimeout(() => request.reply(RAW_USER_WRITE_CONCERN_ERROR));
        }
      });

      makeAndConnectReplSet((err, topology) => {
        // cleanup the server before calling done
        const cleanup = err => topology.close({ force: true }, err2 => done(err || err2));

        if (err) {
          return cleanup(err);
        }

        topology.selectServer('primary', (err, server) => {
          expect(err).to.not.exist;

          server.command(ns('db1'), Object.assign({}, RAW_USER_WRITE_CONCERN_CMD), err => {
            let _err;
            try {
              expect(err).to.be.an.instanceOf(MongoWriteConcernError);
              expect(err.result).to.exist;
              expect(err.result).to.have.property('ok', 1);
              expect(err.result).to.not.have.property('errmsg');
              expect(err.result).to.not.have.property('code');
              expect(err.result).to.not.have.property('codeName');
              expect(err.result).to.have.property('writeConcernError');
            } catch (e) {
              _err = e;
            } finally {
              cleanup(_err);
            }
          });
        });
      });
    });

    it('should propagate writeConcernError.errInfo ', function (done) {
      test.primaryServer.setMessageHandler(request => {
        const doc = request.document;
        if (isHello(doc)) {
          setTimeout(() => request.reply(test.primaryStates[0]));
        } else if (doc.createUser) {
          setTimeout(() => request.reply(RAW_USER_WRITE_CONCERN_ERROR_INFO));
        }
      });

      makeAndConnectReplSet((err, topology) => {
        // cleanup the server before calling done
        const cleanup = err => topology.close(err2 => done(err || err2));

        if (err) {
          return cleanup(err);
        }

        topology.selectServer('primary', (err, server) => {
          expect(err).to.not.exist;

          server.command(ns('db1'), Object.assign({}, RAW_USER_WRITE_CONCERN_CMD), err => {
            let _err;
            try {
              expect(err).to.be.an.instanceOf(MongoWriteConcernError);
              expect(err.result).to.exist;
              expect(err.result.writeConcernError).to.deep.equal(
                RAW_USER_WRITE_CONCERN_ERROR_INFO.writeConcernError
              );
            } catch (e) {
              _err = e;
            } finally {
              cleanup(_err);
            }
          });
        });
      });
    });
  });
});
