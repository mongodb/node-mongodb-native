'use strict';

const expect = require('chai').expect;
const { getSymbolFrom } = require('../tools/utils');
const {
  MongoError,
  MongoServerError,
  MongoDriverError,
  MongoNetworkError,
  MongoNetworkTimeoutError,
  MongoParseError,
  MongoSystemError,
  MongoServerSelectionError,
  MongoWriteConcernError
} = require('../../src/error');
const { MongoBulkWriteError } = require('../../src/bulk/common');
const { PoolClosedError, WaitQueueTimeoutError } = require('../../src/cmap/errors');

describe('MongoErrors', () => {
  const errorClasses = {
    MongoError,
    MongoServerError,
    MongoDriverError,
    MongoNetworkTimeoutError,
    MongoParseError,
    MongoSystemError,
    MongoServerSelectionError,
    MongoWriteConcernError,
    MongoBulkWriteError,
    PoolClosedError,
    WaitQueueTimeoutError
  };

  for (const errorName in errorClasses) {
    describe(errorName, () => {
      it(`name should be read-only`, () => {
        // Dynamically create error class with message
        let error = new errorClasses[errorName]('generated by test');

        // expect name property to be class name
        expect(error.name).to.eql(errorName);
        expect(() => {
          error.name = 'renamed by test';
        }).to.throw(TypeError);
      });
    });
  }

  describe('MongoNetworkError', () => {
    it(`name should be read-only`, () => {
      let error = new MongoNetworkError('generated by test');

      // expect name property to be class name
      expect(error.name).to.eql('MongoNetworkError');
      expect(() => {
        error.name = 'renamed by test';
      }).to.throw(TypeError);
    });

    it('should only define beforeHandshake symbol if boolean option passed in', function () {
      const errorWithOptionTrue = new MongoNetworkError('', { beforeHandshake: true });
      expect(getSymbolFrom(errorWithOptionTrue, 'beforeHandshake', false)).to.be.a('symbol');

      const errorWithOptionFalse = new MongoNetworkError('', { beforeHandshake: false });
      expect(getSymbolFrom(errorWithOptionFalse, 'beforeHandshake', false)).to.be.a('symbol');

      const errorWithBadOption = new MongoNetworkError('', { beforeHandshake: 'not boolean' });
      expect(getSymbolFrom(errorWithBadOption, 'beforeHandshake', false)).to.be.an('undefined');

      const errorWithoutOption = new MongoNetworkError('');
      expect(getSymbolFrom(errorWithoutOption, 'beforeHandshake', false)).to.be.an('undefined');
    });
  });
});
