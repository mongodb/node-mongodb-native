'use strict';

const expect = require('chai').expect;
const { getSymbolFrom } = require('../tools/utils');
const { MongoNetworkError } = require('../../src/index');
const { MongoBulkWriteError } = require('../../src/bulk/common');
const { PoolClosedError, WaitQueueTimeoutError } = require('../../src/cmap/errors');

describe('MongoErrors', () => {
  // import errors as object
  let errorClasses = Object.fromEntries(
    Object.entries(require('../../src/index')).filter(([key]) => key.endsWith('Error'))
  );
  errorClasses = { ...errorClasses, MongoBulkWriteError, PoolClosedError, WaitQueueTimeoutError };

  for (const errorName in errorClasses) {
    describe(errorName, () => {
      it(`name should be read-only`, () => {
        // Dynamically create error class with message
        let error = new errorClasses[errorName]('generated by test');
        const errorPrototype = Object.getPrototypeOf(error);

        // expect name property to be class name
        expect(error.name).to.have.property('name', errorName);
        expect(errorPrototype).to.have.ownPropertyDescriptor('name').that.has.property('get');
      });
    });
  }

  describe('MongoNetworkError', () => {
    it(`name should be read-only`, () => {
      let error = new MongoNetworkError('generated by test');

      // expect name property to be class name
      expect(error.name).to.eql('MongoNetworkError');
      expect(() => {
        error.name = 'renamed by test';
      }).to.throw(TypeError);
    });

    it('should only define beforeHandshake symbol if boolean option passed in', function () {
      const errorWithOptionTrue = new MongoNetworkError('', { beforeHandshake: true });
      expect(getSymbolFrom(errorWithOptionTrue, 'beforeHandshake', false)).to.be.a('symbol');

      const errorWithOptionFalse = new MongoNetworkError('', { beforeHandshake: false });
      expect(getSymbolFrom(errorWithOptionFalse, 'beforeHandshake', false)).to.be.a('symbol');

      const errorWithBadOption = new MongoNetworkError('', { beforeHandshake: 'not boolean' });
      expect(getSymbolFrom(errorWithBadOption, 'beforeHandshake', false)).to.be.an('undefined');

      const errorWithoutOption = new MongoNetworkError('');
      expect(getSymbolFrom(errorWithoutOption, 'beforeHandshake', false)).to.be.an('undefined');
    });
  });
});
